package net.sf.jclec.algorithm.memetic;

import net.sf.jclec.IConfigure;
import net.sf.jclec.IIndividual;
import net.sf.jclec.util.opt.IOptimizer;
import net.sf.jclec.util.random.IRandGen;
import net.sf.jclec.util.random.IRandGenFactory;

import net.sf.jclec.algorithm.classic.SS;

import net.sf.jclec.selector.BettersSelector;
import net.sf.jclec.selector.WorsesSelector;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationRuntimeException;

import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * <strong><u>M</u></strong>emetic <strong><u>S</u></strong>teady <strong><u>S</u></strong>tate algorithm
 * 
 * @author Amelia Zafra - Sebastián Ventura
 *
 * @param <I> Type of individuals in system
 */

public class MSS extends SS 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 6553663167024278933L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Individuals Optimizer */
	
	protected IOptimizer localOptimizer;
		
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////		
	
	/** Random number generator	 */
	
	protected IRandGen randgen;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////

	/** Betters selector (used in update phase) */
	
	protected BettersSelector bettersSelector = new BettersSelector (this);
	
	/** Worses selector (used in update phase) */
	
	protected WorsesSelector worsesSelector = new WorsesSelector (this);
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */
	
	public MSS() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------------- Getting and setting properties
	/////////////////////////////////////////////////////////////////
	
	/**
	 * {@inheritDoc}
	 * 
	 * After random generators factory is set, set the random numbers 
	 * generator used in optimization phase
	 */
	
	@Override
	public void setRandGenFactory(IRandGenFactory randGenFactory) 
	{
		// Call super() method
		super.setRandGenFactory(randGenFactory);
		// Set random generator
		randgen = this.randGenFactory.createRandGen();		
	}
	
	/**
	 * Access to individuals optimizer.
	 * 
	 * @return Individuals optimizer
	 */
	
	public IOptimizer getLocalOptimizer() 
	{
		return localOptimizer;
	}

	/**
	 * Set individuals optimizer
	 * 
	 * @param optimizer Individuals optimizer
	 */
	
	public void setLocalOptimizer(IOptimizer optimizer) 
	{
		// Set optimizer
		this.localOptimizer = optimizer;
		// Set optimizer context
		optimizer.contextualize(this);
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------- Implementing IConfigure interface
	/////////////////////////////////////////////////////////////////
	
	
	@SuppressWarnings("unchecked")
	public void configure(Configuration settings)
	{
		// Call super.configure() method
		super.configure(settings);
		// Configure optimizer
		try {
			// Optimizer classname
			String optimizerClassname = 
				settings.getString("local-optimizer[@type]");
			// Optimizer class
			Class<? extends IOptimizer> optimizerClass = (Class<? extends IOptimizer>) Class.forName(optimizerClassname);
			// Optimizer instance
			IOptimizer optimizer = optimizerClass.newInstance();
			// Configure optimizer if necessary
			if (optimizer instanceof IConfigure) {
				Configuration optimizerConfiguration = settings.subset("local-optimizer");
				((IConfigure) optimizer).configure(optimizerConfiguration);
			}
			setLocalOptimizer(optimizer);
			
		} 
		catch (ClassNotFoundException e) {
			throw new ConfigurationRuntimeException("Illegal optimizer classname");
		} 
		catch (InstantiationException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of optimizer", e);
		} 
		catch (IllegalAccessException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of optimizer", e);
		}		
	}
	
	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting java.lang.Object methods
	/////////////////////////////////////////////////////////////////

	@Override
	public boolean equals(Object other)
	{
		if (other instanceof MSS) {
			MSS cother = (MSS) other;
			EqualsBuilder eb = new EqualsBuilder();
			// Call super method
			eb.appendSuper(super.equals(other));
			// Number of parents
			eb.append(numberOfParents, cother.numberOfParents);
			// Parents selector
			eb.append(parentsSelector, cother.parentsSelector);
			// Mutator
			eb.append(mutator, cother.mutator);
			// Recombinator
			eb.append(recombinator, cother.recombinator);
			// Return test result
			return eb.isEquals();
		}
		else {
			return false;
		}
	}
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------- Overwriting BaseAlgorithm methods
	/////////////////////////////////////////////////////////////////

	@Override
	public void doIterate() 
	{
		// Increments generation counter
		generation++;
		// Do selection
		doSelection();
		// Do generation
		doGeneration();
		// Do optimization
		doOptimization();
		// Do replacement
		doReplacement();
		// Do update
		doUpdate();
		// Do control
		doControl();
	}

	
	/**
	 * Apply the  optimizer to the new individuals. A good individual 
	 * has more  probability than a worse  individual of applying him
	 * the optimizer.
	 */
	
	protected void doOptimization() 
	{		
		double pBL;
			
		IIndividual worstInd = worsesSelector.select(bset,1).get(0);
		List<IIndividual> removableInd = new ArrayList<>();
		List<IIndividual> addedInd = new ArrayList<>();
		
		for(IIndividual ind:cset){
			pBL = probabilityToApplyOptimizer(ind, worstInd);
			
			if(randgen.uniform(0,1) < pBL ){
				addedInd.add(localOptimizer.optimize(ind));
				removableInd.add(ind);
				//cset.add(localOptimizer.optimize(ind));
				//cset.remove(ind);
			}
		}
		cset.addAll(addedInd);
		cset.removeAll(removableInd);
	}

	/**
	 * 
	 * The new son is compared with the worse individual of the current 
	 * population, if the son is better than worse individual, a 
	 * optimization process is applied to son, else the probability of 
	 * applying a optimization process to son is 0.0625
	 * 
	 * @param ind the generated new individual
	 * @param worstInd The worst individual of the current population
	 * 
	 * @return Probability of applying a local optimizer to the individual.
	 */
	
	protected double probabilityToApplyOptimizer(IIndividual ind, IIndividual worstInd)
	{
		
		if(evaluator.getComparator().compare(ind.getFitness(),worstInd.getFitness()) == 1) {
			return 1.0;			
		}
		else {
			return 0.0625;
		}
	}
}
