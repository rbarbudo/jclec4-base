package net.sf.jclec.ge.mut;

import net.sf.jclec.IPopulation;
import net.sf.jclec.ISystem;
import net.sf.jclec.ge.GEIndividual;
import net.sf.jclec.symreg.Cte;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.TerminalNode;
import net.sf.jclec.util.opt.IOptimizer;

/**
 * One locus mutation applied to GE. In addition, this mutatot applied the 
 * Nelder-Mead algorithm to the constants optimization
 * 
 * @author Rafael Barbudo Lunar
 */

public class OneLocusMutatorCte extends OneLocusMutator
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -1756869206810217866L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////

	/** Local optimizer */
	
	protected IOptimizer optimizer;
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * {@inheritDoc}
	 */
	
	protected void mutateNext() 
	{	
		// Genome length
		int gl = species.getGenotypeLength();
		// Individual to mutate
		GEIndividual mutant = 
			(GEIndividual) parentsBuffer.get(parentsCounter);
		
		SyntaxTree phenome = mutant.getPhenotype();
		int nConstants = phenome.nOfNodes("cte");
		
		
		// Create array with constant values
		double [] constants = new double [nConstants];
		int cteIdx = 0;
		
		for(int i=0; i<phenome.size(); i++) {
			String symbol = phenome.getNode(i).getSymbol();
			if(symbol.equals("cte")) {
				constants[cteIdx] = ((Cte) ((TerminalNode)phenome.getNode(i)).getCode()).getValue();
				cteIdx++;
			}
		}

		// Creates mutant genotype
		int [] mgenome = new int[gl];
		System.arraycopy(mutant.getGenotype(), 0, mgenome, 0, gl);
		// Choose mutation point
		int mp = getMutableLocus();
		// Flip selected point
		flip(mgenome, mp);
		GEIndividual optimizado = species.createAndMapIndividual(mgenome);

		// Add the constants to the mutant
		int phenomeIdx = 0;
		cteIdx = 0;
		
		while(cteIdx < constants.length && phenomeIdx < optimizado.getPhenotype().size()) {
			String symbol = optimizado.getPhenotype().getNode(phenomeIdx).getSymbol();
			if(symbol.equals("cte")) {
				((Cte)((TerminalNode) optimizado.getPhenotype().getNode(phenomeIdx)).getCode()).setValue(constants[cteIdx]);
				cteIdx++;
			}
			phenomeIdx++;
		}
		// Returns the mutant
		sonsBuffer.add(optimizado);
	}
	
	public final void contextualize(ISystem context)
	{	
		if(context instanceof IPopulation) {
			// Contextualize this operator
			this.context = (IPopulation) context;
			// Attach a random generator to this object
			this.randgen = context.createRandGen();
		}
		else
			throw new IllegalArgumentException("This object uses a population as execution context");	
	}
}