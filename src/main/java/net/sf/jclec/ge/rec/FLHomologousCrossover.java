package net.sf.jclec.ge.rec;

import net.sf.jclec.ge.GEIndividual;
import net.sf.jclec.ge.GEIndividualSpecies;
import net.sf.jclec.ge.GERecombinator;

/**
 * Homologous Crossover with genotypes of the same lenght
 * 
 * @author Rafael Barbudo Lunar
 */

public class FLHomologousCrossover extends GERecombinator 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by eclipse */
	
	private static final long serialVersionUID = 341170779019513797L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public FLHomologousCrossover() {
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	/**
	 * {@inheritDoc}
	 */
	
	@Override
	protected void recombineNext() 
	{
		// Get the genotypes of the parents
		int [] p0genome = 
				( (GEIndividual) parentsBuffer.get(parentsCounter)).getGenotype();
		int [] p1genome = 
				( (GEIndividual) parentsBuffer.get(parentsCounter + 1)).getGenotype();
		
		// Get the lenght of the genotypes
		int p0gl = p0genome.length;
		int p1gl = p1genome.length;
		
		// Get the first point of dissimilarity of derivation
		int cp0 = ((GEIndividualSpecies)context.getSpecies()).getGenotypeSchema()
				.getPointOfDerivationDissimilarity(p0genome, p1genome);
		
		if(cp0 == -1) {
			// Get the first parent
			sonsBuffer.add(species.createIndividual(p0genome));
			// Get the second parent
			sonsBuffer.add(species.createIndividual(p1genome));
		}
		else
		{
			// Get the min lenght of the genotypes in case they were differents
			int mingl = Math.min(p0gl, p1gl);
			
			// Get the second crossover point
			int cp1 = randgen.choose(cp0 + 1, mingl);	
						
			// Get the first son
			int[] s0genome = new int[p0gl];
			System.arraycopy(p0genome, 0, s0genome, 0, cp0);
			System.arraycopy(p1genome, cp0, s0genome, cp0, cp1 - cp0);
			System.arraycopy(p0genome, cp1, s0genome, cp1, p0gl - cp1);
			
			// Get the second son
			int[] s1genome = new int[p1gl];
			System.arraycopy(p1genome, 0, s1genome, 0, cp0);
			System.arraycopy(p0genome, cp0, s1genome, cp0, cp1 - cp0);
			System.arraycopy(p1genome, cp1, s1genome, cp1, p1gl - cp1);
						
			// Add the offspring to the buffer
			sonsBuffer.add(species.createIndividual(s0genome));
			sonsBuffer.add(species.createIndividual(s1genome));
		}
	}
	
	/**
	 * {@inheritDoc}
	 */
	
	@Override
	public boolean equals(Object other)
	{
		if(other instanceof FLHomologousCrossover) 
			return true;
		else 
			return false;
	}
}