package net.sf.jclec.util.opt;

import java.util.List;
import java.util.ArrayList;

import net.sf.jclec.IConfigure;
import net.sf.jclec.IIndividual;
import net.sf.jclec.ISystem;
import net.sf.jclec.exprtree.Constant;
import net.sf.jclec.exprtree.IPrimitive;
import net.sf.jclec.ge.GEIndividual;
import net.sf.jclec.ge.GESpecies;
import net.sf.jclec.ISpecies;
import net.sf.jclec.IPopulation;

import net.sf.jclec.util.range.IRange;
import net.sf.jclec.util.range.Interval;

import net.sf.jclec.selector.BettersSelector;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeNode;
import net.sf.jclec.syntaxtree.TerminalNode;
import net.sf.jclec.realarray.RealArraySpecies;
import net.sf.jclec.realarray.RealArrayIndividual;

import org.apache.commons.configuration.Configuration;

/**
 * Nelder-Mead simplex optimizer.
 * 
 * @author Amelia Zafra
 */

public class NelderMeadOptimizer extends AbstractOptimizer implements IConfigure
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */
	
	private static final long serialVersionUID = 7436334275449929175L;

	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Contraction factor */
	
	protected double contractionFactor;
	
	/** Expansion factor */
	
	protected double expansionFactor;
	
	/** Reflection Factor */
	
	protected double reflectionFactor;
	
	/** Number of maximum iterations */
	
	protected int maxIterations;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////
	
	/** Best Selector */
	
	BettersSelector bettersSelector;

	/** Genotype schema */
	
	protected IRange [] schema;
	
	/** Specie */
	
	protected ISpecies spc;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
		
	/**
	 * Empty constructor
	 */
	
	public NelderMeadOptimizer() 
	{
		super();
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	// Setting and getting properties

	/** Contraction factor */	
	public double getContractionFactor()
	{
		return contractionFactor;
	}

	public void setContractionFactor(double contractionFactor)
	{
		this.contractionFactor = contractionFactor;
	}
	
	/** Expansion factor */	
	public double getExpansionFactor()
	{
		return expansionFactor;
	}
	
	public void setExpansionFactor(double expansionFactor)
	{
		this.expansionFactor = expansionFactor;
	}
	
	/** Reflection factor */
	public double getReflectionFactor()
	{
		return reflectionFactor;
	}
	
	public void setReflectionFactor(double reflectionFactor)
	{
		this.reflectionFactor = reflectionFactor;
	}
	
	
	/** Maximun iterations */
	public int getMaxIterations()
	{
		return maxIterations;
	}
	
	public void setMaxIterations(int maxIterations)
	{
		this.maxIterations = maxIterations;
	}
	
	// TODO comentar metodos para encapsular el tipo de individuo
	
	/*  Sirven para hacer generico el metodo y que trabaje con cualquier tipo de individuo
		Por ejemplo si estamos trabajando con un individuo de tipo RealIndividual el array lo
		constituirá su genotipo pero si estamos trabajando con GE el array será el pull de constantes
	*/
	
	public void setRealArray(IIndividual ind, double [] realArray)
	{
		if (spc instanceof RealArraySpecies)
			((RealArrayIndividual) ind).setGenotype(realArray);
		if(spc instanceof GESpecies) {
			int index = 0;
			SyntaxTree phenotype = ((GEIndividual)ind).getPhenotype();					
			for (int i=0; i<phenotype.size(); i++) {
				SyntaxTreeNode node = phenotype.getNode(i);
				if(node instanceof TerminalNode) {
					IPrimitive code = ((TerminalNode) node).getCode();
					if(code instanceof Constant) {
						((Constant) code).setValue(realArray[index]);
						index++;
					}
				}
			}
		}
		else
			throw new IllegalArgumentException("Species doesn't expected");
	}
	
	public double [] getRealArray(IIndividual ind)
	{
		double [] realArray;
				
		if (spc instanceof RealArraySpecies)
			realArray = ((RealArrayIndividual) ind).getGenotype();
		if(spc instanceof GESpecies) {
			
			ArrayList <Double> lReal = new ArrayList<Double>();
			SyntaxTree phenotype = ((GEIndividual)ind).getPhenotype();
			
			for (int i=0; i<phenotype.size(); i++) {
				SyntaxTreeNode node = phenotype.getNode(i);
				if(node.getSymbol().equals("cte")) {
					TerminalNode tNode = (TerminalNode) node;
					lReal.add(((Constant)tNode.getCode()).getValue());
				}
			}
			realArray = new double[lReal.size()];
			for(int i=0; i<realArray.length; i++) {
				realArray[i] = lReal.get(i);
			}
		}
		else
			throw new IllegalArgumentException("Species doesn't expected");
		
		return realArray;	
	}
	
	// IConfigure interface
	
	/**
	 * {@inheritDoc} 
	 */
	
	// TODO Revisar para ver en que momento se llama (cada cierto numero de it)
	
	public void configure(Configuration configuration)
	{
		double contractionFactor = configuration.getDouble("contraction-factor",0.5);
		setContractionFactor(contractionFactor);
		
		double reflectionFactor = configuration.getDouble("reflection-factor",1.0);
		setReflectionFactor(reflectionFactor);
		
		double expansionFactor = configuration.getDouble("expansion-factor",2.0);
		setExpansionFactor(expansionFactor);
		
		int maxIterations = configuration.getInt("max-iterations",10);
		setMaxIterations(maxIterations);
		
					
	}	
	
	// IOptimizer interface
			
	/**
	 * {@inheritDoc} 
	 */
	
	public void contextualize(ISystem context)
	{
		super.contextualize(context);
		
		spc = ((IPopulation) context).getSpecies();
		
		// Get context species
		if (spc instanceof RealArraySpecies) {
			schema = ((RealArraySpecies) spc).getGenotypeSchema();
		}
		if(spc instanceof GESpecies) {
			schema = ((GESpecies) spc).getGenotypeSchema().getIndividualConstants();
		}
		else {
			throw new IllegalArgumentException("Species doesn't expected");
		}
		bettersSelector = new BettersSelector(context);
	}
	
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////	
	
	protected void restart(List<IIndividual> soluciones, IIndividual mejorSolucion, int longitud)
	{
		int elem = soluciones.size();		
		for(int i=0; i<elem; i++) {			
			if(soluciones.get(i).equals(mejorSolucion)){
				for(int j=0; j<longitud; j++)
				{
					//soluciones.get(i).getGenotype()[j] = 0.5*(soluciones.get(i).getGenotype()[j] + mejorSolucion.getGenotype()[j]);
					getRealArray(soluciones.get(i))[j] = 0.5*getRealArray(soluciones.get(i))[j] + getRealArray(mejorSolucion)[j];
				}
			}	
		}
		evaluator.evaluate(soluciones);
	}
	
	
	protected void move(IIndividual actual, IIndividual indRespecto, int longitud, double factor, double [] valorCentroide){
		
		double  a, b;
		double [] realArray = new double[longitud];
		double extremoSuperior, extremoInferior;
		
	
		for(int i=0; i<longitud; i++){

			//Use the factor and the centroide to change the solution 
			//realArray[i] =  valorCentroide[i] + factor*(valorCentroide[i]- indRespecto.getGenotype()[i]);
			realArray[i] =  valorCentroide[i] + factor*(valorCentroide[i]- getRealArray(indRespecto)[i]);
			
			//Check the limits of the interval
			if(spc instanceof RealArraySpecies) {
				a = ((Interval) schema[i]).getLeft();
				b = ((Interval) schema[i]).getRight();
			}
			if(spc instanceof GESpecies) {
				a = ((Interval) schema[0]).getLeft();
				b = ((Interval) schema[0]).getRight();
			}
			else {
				throw new IllegalArgumentException("Species doesn't expected");
			}
	
			extremoInferior = Math.min(a,b);
			extremoSuperior = Math.max(a,b);
			
			if(realArray[i] < extremoInferior)
				realArray[i] = extremoInferior;
			if(realArray[i] > extremoSuperior)
				realArray[i] = extremoSuperior;
		}
		
		//actual.setGenotype(realArray);
		setRealArray(actual, realArray);
	}
	
	protected List<IIndividual> obtainExtremeSolutions(List<IIndividual> source, int longitud){
		
		List<IIndividual> result = new ArrayList<IIndividual>();
	
		List<IIndividual> aux = bettersSelector.select(source, source.size());
		
		
		//Add the worst individual
		result.add(aux.get(source.size()-1));
		//Add the second worst individual
		result.add(aux.get(source.size()-2));
		//Add the best individual
		result.add(aux.get(0));
		
		
		return result;
	}
	
	
	protected void calculateCentroide(List<IIndividual> soluciones, IIndividual worst, double [] valorCentroide, int longitud){
		
		for(int i=0; i<longitud; i++)
			valorCentroide[i] = 0.0;
		
		for(int j=0; j<longitud; j++)
		{
			for(int i=0; i<soluciones.size(); i++){
				if(!soluciones.get(i).equals(worst))
				{
					//valorCentroide[j] += (soluciones.get(i)).getGenotype()[j];
					valorCentroide[j] += getRealArray(soluciones.get(i))[j];
				}	
			}
		}
		
		for(int i=0; i<longitud; i++)
		{	
			valorCentroide[i] /= longitud;
		}
		
	}
	
 
	protected List<IIndividual> generateSolutions(IIndividual solucionInicial, int longitud){
		
		List<IIndividual> result = new ArrayList<IIndividual>();
		double a,b, dif;
		double extremoSuperior, extremoInferior;
		
	
		IIndividual copiaSolucionInicial = (IIndividual) solucionInicial.copy();
		result.add(copiaSolucionInicial);
		double [] realArray = new double[longitud];
		
		for(int i=0; i<longitud; i++){
						
			IIndividual nuevaSolucion = (IIndividual) solucionInicial.copy();
			//realArray = nuevaSolucion.getGenotype();
			realArray = getRealArray(nuevaSolucion);
			
			//Assign new values to the solution
			if(spc instanceof RealArraySpecies) {
				a = ((Interval) schema[i]).getLeft();
				b = ((Interval) schema[i]).getRight();
			}
			if(spc instanceof GESpecies) {
				a = ((Interval) schema[0]).getLeft();
				b = ((Interval) schema[0]).getRight();
			}
			else {
				throw new IllegalArgumentException("Species doesn't expected");
			}
					
			dif = Math.abs(a-b);
						
			realArray[i] += 0.1*dif;
			
			// Check the limits of the intervals
			extremoInferior = Math.min(a,b);
			extremoSuperior = Math.max(a,b);
			
			if(realArray[i] < extremoInferior)
				realArray[i] = extremoInferior;
			if(realArray[i] > extremoSuperior)
				realArray[i] = extremoSuperior;
			
			//nuevaSolucion.setGenotype(realArray);
			setRealArray(nuevaSolucion, realArray);
			
			result.add(nuevaSolucion);	
		}
		evaluator.evaluate(result);
		return result;
	}
	
	public IIndividual optimize(IIndividual ind) 
	{		
		List<IIndividual> solutions;
		//The first solution is the worst the solution, the second is the
		//second worst solution and the third is the best solution
		List<IIndividual> extremeSolutions;
		List<IIndividual> lextension = new ArrayList<IIndividual>();
		List<IIndividual> lreflection = new ArrayList<IIndividual>();
		List<IIndividual> lcontraction = new ArrayList<IIndividual>();
		IIndividual extension = (IIndividual) ind.copy();

		IIndividual reflection = (IIndividual) ind.copy();
		IIndividual contraction = (IIndividual) ind.copy();
		lextension.add(extension);
		lreflection.add(reflection);
		lcontraction.add(contraction);
		
		//Obtain the lenght of the individuals
		//int length = ind.getGenotype().length;
		int length = getRealArray(ind).length;
		
		if(length > 0) {
			
			double [] centroideValue = new double[length];
	
			for(int i=0; i<length; i++)
			{
				centroideValue[i] = 0.0;
			}
			
			//Generate new solutions
			solutions = generateSolutions(ind, length);
						
			extremeSolutions = obtainExtremeSolutions(solutions, length);
			
			// 0 - It is the worst solution
			// 1 - It is the second worst solution
			// 2 - It is the best solution
			
			for(int i=0; i<maxIterations; i++)
			{
				extremeSolutions = obtainExtremeSolutions(solutions, length);
			
				calculateCentroide(solutions, extremeSolutions.get(0), centroideValue, length);
			
				
				//Change the solution by means of reflection process
				move(reflection, extremeSolutions.get(0), length, reflectionFactor, centroideValue);
				evaluator.evaluate(lreflection);
				
				//If the new solution is better than the best solution, Apply expansion process
				if(evaluator.getComparator().compare(extremeSolutions.get(2).getFitness(),reflection.getFitness()) == -1)
				{
					
					move(extension, reflection, length, expansionFactor, centroideValue);
					
					evaluator.evaluate(lextension);
					
					if(evaluator.getComparator().compare(reflection.getFitness(),extension.getFitness()) == -1){
						//extremeSolutions.get(0).setGenotype(extension.getGenotype());
						setRealArray(extremeSolutions.get(0), getRealArray(extension));
						extremeSolutions.get(0).setFitness(extension.getFitness());
						
					}
					else
					{
						//extremeSolutions.get(0).setGenotype( reflection.getGenotype());
						setRealArray(extremeSolutions.get(0), getRealArray(reflection));
						extremeSolutions.get(0).setFitness( reflection.getFitness());
					
					}
					
				}
				//If the new solutions is better than the second worst solution, add the new solution
				else if(evaluator.getComparator().compare(reflection.getFitness(),extremeSolutions.get(1).getFitness()) == 1){
					
					//extremeSolutions.get(0).setGenotype(reflection.getGenotype());
					setRealArray(extremeSolutions.get(0), getRealArray(reflection));
					extremeSolutions.get(0).setFitness(reflection.getFitness());
				}
				
				else
				{
					//If the new solution is better than the worst solution, add the new solution
					if(evaluator.getComparator().compare(reflection.getFitness(),extremeSolutions.get(0).getFitness()) == 1){
						//extremeSolutions.get(0).setGenotype( reflection.getGenotype());
						setRealArray(extremeSolutions.get(0), getRealArray(reflection));
						extremeSolutions.get(0).setFitness( reflection.getFitness());
					
					}
					else
					{
						//Apply contraction process
						move(contraction, extremeSolutions.get(0), length, contractionFactor, centroideValue);
						evaluator.evaluate(lcontraction);
					
						//If the new solution is better than the worst solution, add the new solution 
						if(evaluator.getComparator().compare(contraction.getFitness(),extremeSolutions.get(0).getFitness()) == 1)
						{
							//extremeSolutions.get(0).setGenotype( contraction.getGenotype());
							setRealArray(extremeSolutions.get(0), getRealArray(contraction));
							extremeSolutions.get(0).setFitness( contraction.getFitness());
						
						}
						else
							// Restart solutions
							restart(solutions, extremeSolutions.get(0), length);
					}
						
				}			
				//
				for(int j=0; j<length; j++)	centroideValue[j] = 0.0;					
			}
			
			extremeSolutions = obtainExtremeSolutions(solutions, length);				
			
			/*System.out.print("opt1:");
			for (int i=0; i< getRealArray(extremeSolutions.get(2)).length; i++) {
				System.out.print(getRealArray(extremeSolutions.get(2))[i]);
			}*/
			
			return extremeSolutions.get(2);
		}
		else {
			/*System.out.print("opt2:");
			for (int i=0; i< getRealArray(ind).length; i++) {
				System.out.print(getRealArray(ind)[i]);
			}*/
			return ind;
		}
	}	
}

